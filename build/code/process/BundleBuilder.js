// Generated by CoffeeScript 1.6.3
var Build, Bundle, BundleBuilder, MasterDefaultsConfig, UError, VERSION, blendConfigs, fs, l, upath, _, _B,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

_B = require('uberscore');

l = new _B.Logger('urequire/process/BundleBuilder');

fs = require('fs');

upath = require('../paths/upath');

MasterDefaultsConfig = require('../config/MasterDefaultsConfig');

blendConfigs = require('../config/blendConfigs');

UError = require('../utils/UError');

Bundle = require('./Bundle');

Build = require('./Build');

VERSION = require('../urequire').VERSION;

/*
  Load config :
    * check options
    * Load (a) bundle(s) and (a) build(s)
    * Build & watch for changes
*/


BundleBuilder = (function() {
  var verboseRef;

  function BundleBuilder(configs, deriveLoader) {
    var err, uerr;
    this.configs = configs;
    this.watch = __bind(this.watch, this);
    l.debug(5, 'uRequire v' + VERSION + ' loading config files...');
    configs.push(MasterDefaultsConfig);
    this.config = blendConfigs(configs, deriveLoader);
    _.defaults(this.config.bundle, {
      filez: ['**/*.*']
    });
    this.setDebugVerbose();
    if (l.deb(10)) {
      l.debug("Final config (with master defaults):\n", this.config);
    }
    l.verbose('uRequire v' + VERSION + ' initializing...');
    if (this.isCheckAndFixPaths() && this.isCheckTemplate()) {
      try {
        this.bundle = new Bundle(this.config.bundle);
        this.build = new Build(this.config.build);
      } catch (_error) {
        err = _error;
        l.er(uerr = "Generic error while initializing @bundle or @build", err);
        throw new UError(uerr, {
          nested: err
        });
      }
    }
  }

  verboseRef = _B.Logger.prototype.verbose;

  BundleBuilder.prototype.setDebugVerbose = function() {
    var _ref;
    _B.Logger.addDebugPathLevel('urequire', this.config.build.debugLevel);
    if (this.config.build.verbose) {
      return _B.Logger.prototype.verbose = verboseRef;
    } else {
      if (this.config.build.debugLevel >= 50) {
        _B.Logger.prototype.verbose = verboseRef;
        if (((_ref = this.build) != null ? _ref.count : void 0) === void 0) {
          return l.warn('Enabling verbose, because debugLevel >= 50');
        }
      } else {
        return _B.Logger.prototype.verbose = function() {};
      }
    }
  };

  BundleBuilder.prototype.buildBundle = function(filenames) {
    var err;
    if (this.build && this.bundle) {
      try {
        this.setDebugVerbose();
        this.build.newBuild();
        return this.bundle.buildChangedResources(this.build, filenames);
      } catch (_error) {
        err = _error;
        if (err != null ? err.quit : void 0) {
          l.er('Quiting building bundle - err is:', err);
        } else {
          l.er('Uncaught exception @ bundle.buildChangedResources', err);
        }
        return this.config.build.done(false);
      }
    } else {
      l.er("buildBundle(): I have !@build or !@bundle - can't build!");
      return this.config.build.done(false);
    }
  };

  BundleBuilder.prototype.watch = function() {
    var buildDone, bundleBuilder, gaze, path, runBuildBundle, runBuildBundleDebounced, watchFiles;
    bundleBuilder = this;
    buildDone = this.build.done;
    this.build.done = function(doneValue) {
      buildDone(doneValue);
      return l.ok("Watched build #" + bundleBuilder.build.count + " took " + ((new Date() - bundleBuilder.build.startDate) / 1000) + "secs - Watching again...");
    };
    watchFiles = [];
    gaze = require('gaze');
    path = require('path');
    fs = require('fs');
    gaze(bundleBuilder.bundle.path + '/**/*.*', function(err, watcher) {
      return watcher.on('all', function(event, filepath) {
        var filepathStat;
        if (event !== 'deleted') {
          try {
            filepathStat = fs.statSync(filepath);
          } catch (_error) {
            err = _error;
          }
        }
        filepath = path.relative(process.cwd(), filepath);
        if (filepathStat != null ? filepathStat.isDirectory() : void 0) {
          return l.log("Adding '" + filepath + "' as new watch directory is NOT SUPPORTED by gaze.");
        } else {
          l.log("Watched file '" + filepath + "' has '" + event + "'.");
          watchFiles.push(path.relative(bundleBuilder.bundle.path, filepath));
          return runBuildBundleDebounced();
        }
      });
    });
    runBuildBundle = function() {
      var runBuildBundleDebounced;
      if (!_.isEmpty(watchFiles)) {
        bundleBuilder.buildBundle(watchFiles);
        watchFiles = [];
        return runBuildBundleDebounced = _.debounce(runBuildBundle, 100);
      } else {
        return l.warn('EMPTY watchFiles = ', watchFiles);
      }
    };
    return runBuildBundleDebounced = _.debounce(runBuildBundle, 100);
  };

  BundleBuilder.prototype.isCheckTemplate = function() {
    var _ref;
    if (_ref = this.config.build.template.name, __indexOf.call(Build.templates, _ref) < 0) {
      l.er("Quitting build, invalid template '" + this.config.build.template.name + "' specified.\nUse -h for help");
      return false;
    }
    return true;
  };

  BundleBuilder.prototype.isCheckAndFixPaths = function() {
    var cfgFile, dirName, pathsOk, _ref, _ref1, _ref2;
    pathsOk = true;
    if (((_ref = this.config.bundle) != null ? _ref.path : void 0) == null) {
      if (cfgFile = (_ref1 = this.configs[0]) != null ? (_ref2 = _ref1.derive) != null ? _ref2[0] : void 0 : void 0) {
        if (dirName = upath.dirname(cfgFile)) {
          l.warn("Assuming path = '" + dirName + "' from 1st configFile: '" + cfgFile + "'");
          this.config.bundle.path = dirName;
        } else {
          l.er("Quitting build, cant assume path from 1st configFile: '" + cfgFile + "'");
          pathsOk = false;
        }
      } else {
        l.er("Quitting build, no path specified.\nUse -h for help");
        pathsOk = false;
      }
    }
    if (pathsOk) {
      if (this.config.build.forceOverwriteSources) {
        this.config.build.dstPath = this.config.bundle.path;
        l.verbose("forceOverwriteSources: dstPath set to '" + this.config.build.dstPath + "'");
      } else {
        if (!(this.config.build.dstPath || ((this.config.build.template.name === 'combined') && this.config.build.template.combinedFile))) {
          l.er("Quitting build:\n  * no --dstPath / `build.dstPath` specified.\n  " + (this.config.build.template.name === 'combined' ? "* no `build.template.combinedFile` specified" : '') + "\nUse -f *with caution* to overwrite sources (no need to specify & ignored --dstPath).");
          pathsOk = false;
        }
        if (this.config.build.dstPath && upath.normalize(this.config.build.dstPath) === upath.normalize(this.config.bundle.path)) {
          l.er("Quitting build, dstPath === path.\nUse -f *with caution* to overwrite sources (no need to specify & ignored --dstPath).");
          pathsOk = false;
        }
      }
    }
    return pathsOk;
  };

  return BundleBuilder;

})();

module.exports = BundleBuilder;
