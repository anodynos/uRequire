// Generated by CoffeeScript 1.6.3
var AlmondOptimizationTemplate, Build, Bundle, BundleBase, BundleFile, DependenciesReporter, Dependency, FileResource, MasterDefaultsConfig, Module, TextResource, UError, debugLevelSkipTempDeletion, fs, globExpand, isFileInSpecs, l, upath, wrench, _, _B,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

_.mixin((require('underscore.string')).exports());

fs = require('fs');

wrench = require('wrench');

_B = require('uberscore');

l = new _B.Logger('urequire/process/Bundle');

globExpand = require('glob-expand');

upath = require('../paths/upath');

MasterDefaultsConfig = require('../config/MasterDefaultsConfig');

AlmondOptimizationTemplate = require('../templates/AlmondOptimizationTemplate');

Dependency = require('../fileResources/Dependency');

DependenciesReporter = require('./../utils/DependenciesReporter');

UError = require('../utils/UError');

BundleFile = require('./../fileResources/BundleFile');

FileResource = require('./../fileResources/FileResource');

TextResource = require('./../fileResources/TextResource');

Module = require('./../fileResources/Module');

Build = require('./Build');

BundleBase = require('./BundleBase');

isFileInSpecs = require('../utils/isFileInSpecs');

debugLevelSkipTempDeletion = 50;

/*
  @todo: doc it!
*/


Bundle = (function(_super) {
  var isCalcPropDepsVars, isCalcPropFiles, logNestedErrorMessages;

  __extends(Bundle, _super);

  function Bundle(bundleCfg) {
    this.rjsOptimize = __bind(this.rjsOptimize, this);
    Bundle.__super__.constructor.apply(this, arguments);
    _.extend(this, bundleCfg);
    this.files = {};
  }

  Bundle.prototype.inspect = function() {
    return l.prettify({
      name: this.name,
      main: this.main,
      files: this.files
    });
  };

  Bundle.calcProperties = {
    filenames: function() {
      var _this = this;
      if (_.isEmpty(this.files)) {
        return _.filter(globExpand({
          cwd: this.path
        }, '**/*.*'), function(f) {
          return isFileInSpecs(f, _this.filez);
        });
      } else {
        return _.keys(this.files);
      }
    },
    dstFilenames: function() {
      return _.map(this.files, function(f) {
        return f.dstFilename;
      });
    },
    fileResources: function() {
      return _.pick(this.files, function(f) {
        return f instanceof FileResource;
      });
    },
    textResources: function() {
      return _.pick(this.files, function(f) {
        return f instanceof TextResource;
      });
    },
    modules: function() {
      return _.pick(this.files, function(f) {
        return f instanceof Module;
      });
    },
    copyBundleFiles: function() {
      var _this = this;
      if (_.isEmpty(this.copy)) {
        return {};
      } else {
        return _.pick(this.files, function(f, filename) {
          return !(f instanceof FileResource) && (isFileInSpecs(filename, _this.copy));
        });
      }
    },
    globalDepsVars: function() {
      var _this = this;
      return this.inferEmptyDepVars(this.getDepsVars(function(dep) {
        var _ref;
        return dep.isGlobal && (dep.pluginName !== 'node') && (_ref = dep.name({
          plugin: false
        }), __indexOf.call(_this.dependencies.node, _ref) < 0);
      }), 'Gathering global-looking dependencies & infering empty DepVars');
    },
    nodeOnlyDepsVars: function() {
      var _this = this;
      l.debug(80, "Gathering 'node'-only dependencies");
      return this.getDepsVars(function(dep) {
        var _ref;
        return (dep.pluginName === 'node') || (_ref = dep.name({
          plugin: false
        }), __indexOf.call(_this.dependencies.node, _ref) >= 0);
      });
    },
    exportsBundleDepsVars: function() {
      return this.inferEmptyDepVars(_.clone(this.dependencies.exports.bundle, true), "Infering empty depVars for `dependencies.exports.bundle`");
    },
    errorFiles: function() {
      return _.pick(this.files, function(f) {
        return f.hasErrors;
      });
    }
  };

  isCalcPropDepsVars = function(p) {
    return _(p).endsWith('depsVars');
  };

  isCalcPropFiles = function(p) {
    return p === 'filenames' || p === 'dstFilenames' || p === 'fileResources' || p === 'textResources' || p === 'modules' || p === 'copyFiles' || p === 'errorFiles';
  };

  Object.defineProperties(Bundle.prototype, {
    doneOK: {
      get: function() {
        return _.isEmpty(this.errorFiles) && (this.errorsCount === 0);
      }
    }
  });

  /*
  Gathers dependencies & corresponding variables/parameters (they bind with), througout this bundle (all modules).
  @param {Function} depFltr a filter, passed a Dependency instance
  @return {dependencies.depsVars} `dependency: ['var1', 'var2']` eg
    {
        'lodash': ['_']
        'jquery': ["$", "jQuery"]
        'models/PersonModel': ['persons', 'personsModel']
    }
  */


  Bundle.prototype.getDepsVars = function(depFltr) {
    var dep, depsVars, dv, k, mod, v, vars, _i, _len, _ref, _ref1;
    if (depFltr == null) {
      depFltr = function() {
        return true;
      };
    }
    depsVars = {};
    _ref = this.modules;
    for (k in _ref) {
      mod = _ref[k];
      _ref1 = mod.getDepsVars(depFltr);
      for (dep in _ref1) {
        vars = _ref1[dep];
        dv = (depsVars[dep] || (depsVars[dep] = []));
        for (_i = 0, _len = vars.length; _i < _len; _i++) {
          v = vars[_i];
          if (__indexOf.call(dv, v) < 0) {
            dv.push(v);
          }
        }
      }
    }
    return depsVars;
  };

  Bundle.prototype.inferEmptyDepVars = function(depVars, whyMessage) {
    var aVar, depName, depVarsPath, dependenciesDepsVars, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (depVars == null) {
      depVars = {};
    }
    if (!_.isEmpty(depVars) && l.deb(70)) {
      l.debug('inferEmptyDepVars:', whyMessage);
    }
    for (depName in depVars) {
      if (_.isEmpty((depVars[depName] || (depVars[depName] = [])))) {
        if (l.deb(80)) {
          l.debug("inferEmptyDepVars : Dependency '" + depName + "' has no corresponding parameters/variable names to bind with.");
        }
        _ref = this.getDepsVars(function(dep) {
          return dep.name({
            relative: 'bundle'
          }) === depName;
        })[depName] || [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          aVar = _ref[_i];
          if (__indexOf.call(depVars[depName], aVar) < 0) {
            depVars[depName].push(aVar);
          }
        }
        if (l.deb(80)) {
          l.debug("inferEmptyDepVars: Dependency '" + depName + "', infering varNames from bundle's Modules: ", depVars[depName]);
        }
        if (_.isEmpty(depVars[depName])) {
          _ref1 = _.map(['depsVars', '_knownDepsVars', 'exports.bundle', 'exports.root'], function(v) {
            return 'dependencies.' + v;
          });
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            depVarsPath = _ref1[_j];
            dependenciesDepsVars = _B.getp(this, depVarsPath, {
              separator: '.'
            });
            if ((!_.isEmpty(dependenciesDepsVars[depName])) && (depVars[depName] !== dependenciesDepsVars[depName])) {
              l.warn("" + whyMessage + ":\n", "Picking var bindings for `" + depName + "` from `@" + depVarsPath + "`", dependenciesDepsVars[depName]);
              _ref2 = dependenciesDepsVars[depName];
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                aVar = _ref2[_k];
                if (__indexOf.call(depVars[depName], aVar) < 0) {
                  depVars[depName].push(aVar);
                }
              }
            }
          }
        }
      }
      if (_.isEmpty(depVars[depName])) {
        this.handleError(new UError("No variable names can be identified for injected or global or node-only dependency '" + depName + "'.\n\nThese variable names are used to :\n  - inject the dependency into each module\n    OR\n  - grab the dependency from the global object, when running as <script> via the 'combined' template.\n\nRemedy:\n\nIf you are injecting eg. at uRequire's config 'bundle.dependencies.exports.bundle', you 'd better declare it as:\n  ```\n    dependencies: exports: bundle: {\n      '" + depName + "': 'VARIABLE(S)_IT_BINDS_WITH',\n      ...\n      jquery: ['$', 'jQuery'],  // Array of known bindings\n      backbone: 'Backbone'      // A String will also do\n    }\n  ```\ninstead of the simpler\n  ```\n    dependencies: exports: bundle: [ '" + depName + "', ...., 'jquery', 'backbone' ]\n  ```\n\nAlternativelly, pick one medicine :\n  - define at least one module that has this dependency + variable binding (either as AMD or commonJs) and uRequire will infer it!\n\n  - declare it in the above format, but in `bundle.dependencies.varNames` and uRequre will pick it from there!\n\n  - use an `rjs.shim`, and uRequire will pick it from there (@todo: NOT IMPLEMENTED YET!)"));
        l.warn(this.dstFilenames);
      }
    }
    return depVars;
  };

  /*
    Processes each filename, either as array of filenames (eg instructed by `watcher`) or all @filenames
  
    If a filename is new, create a new BundleFile (or more interestingly a TextResource or Module)
  
    In any case, refresh() each one, either new or existing. Internally BundleFile notes `hasChanged`. 
  
    @param []<String> with filenames to process.
      @default ALL files from filesystem (property @filenames)
  
    @return null
  */


  Bundle.prototype.loadOrRefreshResources = function(filenames) {
    var bf, dstFilename, err, filename, isNew, lastResourcesWithClazz, lastSrcMain, matchedConverters, resConv, resourceClass, sameDstFile, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    if (filenames == null) {
      filenames = this.filenames;
    }
    if (l.deb(30)) {
      l.debug("\n-\n#####################################################################\nloadOrRefreshResources: filenames.length = " + filenames.length + "\n#####################################################################");
    }
    for (_i = 0, _len = filenames.length; _i < _len; _i++) {
      filename = filenames[_i];
      isNew = false;
      if (!(bf = this.files[filename])) {
        isNew = true;
        lastSrcMain = void 0;
        matchedConverters = [];
        dstFilename = filename;
        _ref = this.resources;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          resConv = _ref[_j];
          if (isFileInSpecs((resConv.isMatchSrcFilename ? filename : dstFilename), resConv.filez)) {
            if (_.isFunction(resConv.convFilename)) {
              dstFilename = resConv.convFilename(dstFilename, filename);
            }
            if (resConv.srcMain) {
              lastSrcMain = resConv.srcMain;
            }
            matchedConverters.push(resConv);
          }
        }
        lastResourcesWithClazz = _.filter(matchedConverters, function(conv) {
          return conv.clazz;
        });
        resourceClass = ((_ref1 = _.last(lastResourcesWithClazz)) != null ? _ref1.clazz : void 0) || BundleFile;
        if (l.deb(80)) {
          l.debug("New *" + resourceClass.name + "*: '" + filename + "'");
        }
        bf = this.files[filename] = new resourceClass({
          bundle: this,
          srcFilename: filename,
          converters: matchedConverters,
          srcMain: lastSrcMain
        });
      }
      if (bf.srcMain && this.build.current[bf.srcMain]) {
        l.debug(60, "Skipping refresh/conversion(s) of '" + bf.srcFilename + "', as part of converted @srcMain='" + bf.srcMain + "'.");
        continue;
      }
      if (l.deb(80)) {
        l.debug("Refreshing " + bf.constructor.name + ": '" + filename + "'");
      }
      try {
        if (bf.refresh()) {
          this.build.addChangedBundleFile(filename, bf);
        }
      } catch (_error) {
        err = _error;
        this.build.addChangedBundleFile(filename, bf);
        if (fs.existsSync(bf.srcFilepath)) {
          bf.reset();
          bf.hasErrors = true;
          this.handleError(new UError("Something wrong while loading/refreshing/processing '" + filename + "'.", {
            nested: err
          }));
        } else {
          l.verbose("Missing file " + bf.srcFilepath + " - removing bundle file " + filename);
          delete this.files[filename];
          if (bf.dstExists && bf.hasErrors !== 'duplicate') {
            l.verbose("Deleting file: " + bf.dstFilepath);
            try {
              fs.unlinkSync(bf.dstFilepath);
            } catch (_error) {
              err = _error;
              l.er("Cant delete destination file '" + bf.dstFilepath + "'.");
            }
          }
          bf.hasErrors = false;
        }
      }
      if (bf.srcMain) {
        this.build.current[bf.srcMain] = true;
      }
      if (isNew && !bf.srcMain) {
        if (sameDstFile = _.find(this.files, function(f) {
          return (f.dstFilename === bf.dstFilename) && (f !== bf);
        })) {
          bf.hasErrors = 'duplicate';
          this.handleError(new UError("Same dstFilename='" + sameDstFile.dstFilename + "' for new resource '" + bf.srcFilename + "' & '" + sameDstFile.srcFilename + "'.", {
            nested: err
          }));
        }
      }
    }
    this.cleanProps((!_.isEmpty(this.build.changedFiles) ? isCalcPropFiles : void 0), (!_.isEmpty(this.build.changedModules) ? isCalcPropDepsVars : void 0));
    l.debug("### finished loadOrRefreshResources: " + (_.size(this.build.changedFiles)) + " changed files.");
    return null;
  };

  /*
    Our only true entry point
    It builds / converts all resources that are passed as filenames
    It 'temporarilly' sets a @build instance, with which it 'guides' the build.
  */


  Bundle.prototype.buildChangedResources = function(build, filenames) {
    var bundleFilenames, diff, err, file, fn, isPartialBuild, _ref,
      _this = this;
    this.build = build;
    if (filenames == null) {
      filenames = this.filenames;
    }
    this.errorsCount = 0;
    isPartialBuild = filenames !== this.filenames;
    if (l.deb(20)) {
      l.debug("\n-\n#####################################################################\nbuildChangedResources: build #" + build.count + "\nbundle.name = " + this.name + ", bundle.main = " + this.main + "\nfilenames.length = " + filenames.length + " " + (!isPartialBuild ? '(full build)' : '') + "\n#####################################################################");
    }
    this.reporter = new DependenciesReporter();
    if (isPartialBuild) {
      if (!this.build.hasFullBuild) {
        l.warn("Forcing a full build (this was a partial build, without a previous full build).");
        _ref = this.files;
        for (fn in _ref) {
          file = _ref[fn];
          file.reset();
        }
        if (this.build.template.name === 'combined') {
          if (!l.deb(debugLevelSkipTempDeletion)) {
            l.debug(40, "Deleting temporary directory '" + this.build.template._combinedFileTemp + "'.");
            try {
              wrench.rmdirSyncRecursive(this.build.template._combinedFileTemp);
            } catch (_error) {
              err = _error;
              l.debug(40, "Can't delete temp dir '" + this.build.template._combinedFileTemp + "' - perhaps it doesnt exist.");
            }
          }
          debugLevelSkipTempDeletion = 0;
          l.warn("Partial/watch build with 'combined' template wont DELETE '" + this.build.template._combinedFileTemp + "' - when you quit 'watch'-ing, delete it your self!");
        }
        this.buildChangedResources(this.build, this.filenames);
        return;
      }
      bundleFilenames = _.filter(filenames, function(f) {
        return isFileInSpecs(f, _this.filez) && f[0] !== '.';
      });
      if (diff = filenames.length - bundleFilenames.length) {
        l.verbose("Ignored " + diff + " non bundle.filez");
        filenames = bundleFilenames;
      }
    }
    if (!filenames.length) {
      l.verbose("No files to process.");
    } else {
      this.loadOrRefreshResources(filenames);
      if (!_.isEmpty(this.build.changedFiles)) {
        this.convertChangedModules();
        this.saveChangedResources();
        this.copyChangedBundleFiles();
        if (this.doneOK && !isPartialBuild && ((this.build.template.name !== 'combined') || this.build.watch)) {
          this.build.hasFullBuild = true;
        }
        if (this.build.template.name === 'combined') {
          return this.combine();
        }
      } else {
        l.verbose("No bundle files *really* changed.");
      }
    }
    this.build.report(this);
    return this.build.done(this.doneOK);
  };

  Bundle.prototype.convertChangedModules = function() {
    var err, fn, mod, _ref;
    if (!_.isEmpty(this.build.changedModules)) {
      if (l.deb(30)) {
        l.debug("\n-\n#####################################################################\nConverting changed modules with template '" + this.build.template.name + "'\n#####################################################################");
      }
      _ref = this.modules;
      for (fn in _ref) {
        mod = _ref[fn];
        if (mod.hasChanged) {
          if (mod.hasErrors) {
            l.er("Not converting '" + mod.srcFilename + "' cause it has errors.");
          } else {
            try {
              mod.adjust(this.build);
              mod.runResourceConverters(function(rc) {
                return rc.isBeforeTemplate && !rc.isAfterTemplate;
              });
              mod.convertWithTemplate(this.build);
              mod.runResourceConverters(function(rc) {
                return rc.isAfterTemplate && !rc.isBeforeTemplate;
              });
              mod.addReportData();
            } catch (_error) {
              err = _error;
              mod.reset();
              mod.hasErrors = true;
              this.handleError(new UError("Error at `convertChangedModules()`", {
                nested: err
              }));
            }
          }
        }
      }
    }
    return null;
  };

  Bundle.prototype.saveChangedResources = function() {
    var err, fn, res, _ref;
    if (!_.isEmpty(this.build.changedResources)) {
      if (l.deb(30)) {
        l.debug("\n-\n#####################################################################\nSaving changed resource files that have a `converted` String\n#####################################################################");
      }
      _ref = this.fileResources;
      for (fn in _ref) {
        res = _ref[fn];
        if (!res.hasChanged) {
          continue;
        }
        if (res.hasErrors) {
          l.er("Not saving with errors: '" + res.dstFilename + "' (srcFilename = '" + res.srcFilename + "').");
        } else {
          if (res.converted && _.isString(res.converted)) {
            try {
              if (_.isFunction(this.build.out)) {
                this.build.out(res.dstFilename, res.converted);
              } else {
                res.save();
              }
            } catch (_error) {
              err = _error;
              res.hasErrors = true;
              this.handleError(new UError("Error while " + (_.isFunction(this.build.out) ? '`build.out()`-ing' : '`save()`-ing') + " resource '" + res.dstFilename + "'.", {
                nested: err
              }));
            }
          } else {
            l.debug(80, "Not saving non-String: '" + res.srcFilename + "' as '" + res.dstFilename + "'.");
          }
        }
        res.hasChanged = false;
      }
    }
    return null;
  };

  Bundle.prototype.copyChangedBundleFiles = function() {
    var bundleFile, copiedCount, err, fn, skippedCount, _ref;
    if (!_.isEmpty(this.copyBundleFiles)) {
      if (l.deb(30)) {
        l.debug("\n-\n#####################################################################\nCopying " + (_.size(this.copyBundleFiles)) + " non-resources files (that match `bundle.copy`)\"\n#####################################################################");
      }
      copiedCount = skippedCount = 0;
      _ref = this.copyBundleFiles;
      for (fn in _ref) {
        bundleFile = _ref[fn];
        if (bundleFile.hasChanged) {
          try {
            if (bundleFile.copy()) {
              copiedCount++;
            } else {
              skippedCount++;
            }
            bundleFile.hasChanged = false;
          } catch (_error) {
            err = _error;
            bundleFile.hasErrors = true;
            this.handleError(err);
          }
        }
      }
    }
    return this.build._copied = [copiedCount, skippedCount];
  };

  Bundle.prototype.inferMain = function() {
    var mainCand, mainMod, _i, _len, _ref;
    _ref = [this.name, 'index', 'main'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      mainCand = _ref[_i];
      if (!(mainCand && !this.main)) {
        continue;
      }
      mainMod = _.find(this.modules, function(m) {
        return m.path === mainCand;
      });
      if (mainMod) {
        this.main = mainMod.path;
        l.warn("combine() note: 'bundle.main', your *entry-point module* was missing from bundle config(s).\nIt's defaulting to " + (this.main === this.name ? 'bundle.name = ' : '') + "'" + this.main + "', as uRequire found an existing '" + this.path + "/" + mainMod.srcFilename + "' module in your path.");
      }
    }
    if (!this.main) {
      return this.handleError(new UError("'bundle.main' is missing (after so much effort).\nNo module found either as name = '" + this.name + "', nor as ['index', 'main']."));
    }
  };

  /*
  */


  Bundle.prototype.combine = function() {
    var almondTemplates, depfilename, err, genCode, rjsConfig, _ref;
    if (_.isEmpty(this.build.changedModules)) {
      l.verbose("Not executing *'combined' template optimizing with r.js*: no @modules changed in build #" + this.build.count + ".");
      this.build.report(this);
      this.build.done(this.doneOK);
      return;
    } else {
      if (_.size(this.build.errorFiles)) {
        if ((_.size(this.build.changedModules) - _.size(this.build.errorFiles)) <= 0) {
          l.er("Not executing *'combined' template optimizing with r.js*: no changed modules without error in build #" + this.build.count + ".");
          this.build.report(this);
          this.build.done(this.doneOK);
          return;
        } else {
          l.warn("Executing *'combined' template optimizing with r.js*: although there are errors in build #" + this.build.count + " (using last valid saved modules).");
        }
      }
    }
    if (l.deb(30)) {
      l.debug("\n-\n#####################################################################\n'combined' template: optimizing with r.js & almond\n#####################################################################");
    }
    this.inferMain();
    almondTemplates = new AlmondOptimizationTemplate(this);
    _ref = almondTemplates.dependencyFiles;
    for (depfilename in _ref) {
      genCode = _ref[depfilename];
      TextResource.save(upath.join(this.build.template._combinedFileTemp, depfilename + '.js'), genCode);
    }
    this.copyAlmondJs();
    this.copyWebMapDeps();
    try {
      fs.unlinkSync(this.build.template.combinedFile);
    } catch (_error) {
      err = _error;
    }
    rjsConfig = {
      paths: _.extend(almondTemplates.paths, this.getRequireJSConfig().paths),
      wrap: almondTemplates.wrap,
      baseUrl: this.build.template._combinedFileTemp,
      include: [this.main],
      deps: _.keys(this.nodeOnlyDepsVars),
      out: this.build.template.combinedFile,
      name: 'almond'
    };
    if (rjsConfig.optimize = this.build.optimize) {
      rjsConfig[this.build.optimize] = this.build[this.build.optimize];
    } else {
      rjsConfig.optimize = "none";
    }
    if (l.deb(90)) {
      rjsConfig.logLevel = 0;
    }
    return this.rjsOptimize(rjsConfig);
  };

  Bundle.prototype.requirejs = require('requirejs');

  Bundle.prototype.rjsOptimize = function(rjsConfig) {
    var rjsStartDate,
      _this = this;
    l.verbose("requirejs.optimize (v" + this.requirejs.version + ") with uRequire's 'build.js' = \n", _.omit(rjsConfig, ['wrap']));
    rjsStartDate = new Date();
    return this.requirejs.optimize(rjsConfig, function(buildResponse) {
      if (l.deb(20)) {
        l.debug('@requirejs.optimize rjsConfig, (buildResponse)-> = ', buildResponse);
      }
      l.debug(60, 'Checking r.js output file...');
      if (fs.existsSync(_this.build.template.combinedFile)) {
        l.ok("Combined file '" + _this.build.template.combinedFile + "' written successfully for build #" + _this.build.count + ", rjs.optimize took " + ((new Date() - rjsStartDate) / 1000) + "secs .");
        if (!_.isEmpty(_this.globalDepsVars)) {
          if ((!_this.build.watch) || l.deb(50)) {
            l.verbose("Global bindinds: make sure the following global dependencies:\n", _this.globalDepsVars, "\n\nare available when combined script '" + _this.build.template.combinedFile + "' is running on:\n\na) nodejs: they should exist as a local `nodes_modules`.\n\nb) Web/AMD: they should be declared as `rjs.paths` (and/or `rjs.shim`)\n\nc) Web/Script: the binded variables (eg '_' or '$')\n   must be a globally loaded (i.e `window.$`) BEFORE loading '" + _this.build.template.combinedFile + "'");
          }
        }
        if (!(l.deb(debugLevelSkipTempDeletion) || _this.build.watch)) {
          l.debug(40, "Deleting temporary directory '" + _this.build.template._combinedFileTemp + "'.");
          wrench.rmdirSyncRecursive(_this.build.template._combinedFileTemp);
        } else {
          l.debug("NOT Deleting temporary directory '" + _this.build.template._combinedFileTemp + "', due to build.watch || debugLevel >= " + debugLevelSkipTempDeletion + ".");
        }
        _this.build.report(_this);
        return _this.build.done(_this.doneOK);
      } else {
        l.er("Combined file '" + _this.build.template.combinedFile + "' NOT written - this should not have happened, requirejs reported success.\nCheck requirejs's build response:\n", buildResponse);
        _this.build.report(_this);
        return _this.build.done(false);
      }
    }, function(errorResponse) {
      _this.build.report(_this);
      l.er('@requirejs.optimize errorResponse: ', errorResponse, "\n\nCombined file '" + _this.build.template.combinedFile + "' NOT written.\"\n\n  Some remedy:\n\n   a) Is your *bundle.main = '" + _this.main + "'* or *bundle.name = '" + _this.name + "'* properly defined ?\n      - 'main' should refer to your 'entry' module, that requires all other modules - if not defined, it defaults to 'name'.\n      - 'name' is what 'main' defaults to, if its a module.\n\n   b) Perhaps you have a missing dependcency ?\n      r.js doesn't like this at all, but it wont tell you unless logLevel is set to error/trace, which then halts execution.\n\n   c) Re-run uRequire with debugLevel >=90, to enable r.js's logLevel:0 (trace).\n      *Note this prevents uRequire from finishing properly / printing this message!*\n\n   Note that you can check the AMD-ish files used in temporary directory '" + _this.build.template._combinedFileTemp + "'.\n\n   More remedy on the way... till then, you can try running r.js optimizer your self, based on the following build.js: \u001b[0m\n", rjsConfig);
      return _this.build.done(false);
    });
  };

  Bundle.prototype.getRequireJSConfig = function() {
    return {};
  };

  Object.defineProperty(Bundle.prototype, 'mergedPreDefineIFINodesCode', {
    get: function() {
      var PreDefineIFI_Declarations, PreDefineIFI_statements, addbodyNode, isLikeCode, m, mod, node, toAst, toCode, _i, _len, _ref, _ref1;
      isLikeCode = Module.isLikeCode, toCode = Module.toCode, toAst = Module.toAst;
      if (l.deb(80)) {
        l.debug("Merging pre-Define IFI declarations and statements from all " + (_.keys(this.modules).length) + " @modules, into a common section.");
      }
      PreDefineIFI_Declarations = [];
      PreDefineIFI_statements = [];
      addbodyNode = function(node) {
        var decl, dublicateDecl, _i, _len, _ref, _results;
        if (node.type === 'VariableDeclaration') {
          _ref = node.declarations;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            decl = _ref[_i];
            if (!_.any(PreDefineIFI_Declarations, function(fd) {
              return _.isEqual(decl, fd);
            })) {
              if (dublicateDecl = _.find(PreDefineIFI_Declarations, function(fd) {
                return isLikeCode({
                  type: decl.type,
                  id: decl.id
                }, fd);
              })) {
                _results.push(this.handleError(new UError("Duplicate var declaration while merging pre-Define IFI statements:\n\n" + (toCode(decl)) + "\n\nis a duplicate of\n\n" + (toCode(dublicateDecl)))));
              } else {
                l.debug(90, "Merging pre-Define IFI statements - Adding declaration of '" + decl.id.name + "'");
                _results.push(PreDefineIFI_Declarations.push(decl));
              }
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        } else {
          if (!_.any(PreDefineIFI_statements, function(fd) {
            return _.isEqual(node, fd);
          })) {
            return PreDefineIFI_statements.push(node);
          }
        }
      };
      _ref = this.modules;
      for (m in _ref) {
        mod = _ref[m];
        _ref1 = mod.AST_preDefineIFINodes || [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          node = _ref1[_i];
          addbodyNode(node);
        }
      }
      if (!_.isEmpty(PreDefineIFI_Declarations)) {
        PreDefineIFI_statements.unshift({
          type: 'VariableDeclaration',
          declarations: PreDefineIFI_Declarations,
          kind: 'var'
        });
      }
      return toCode(PreDefineIFI_statements);
    }
  });

  Bundle.prototype.copyAlmondJs = function() {
    var err;
    try {
      return BundleFile.copy("" + __dirname + "/../../../node_modules/almond/almond.js", upath.join(this.build.template._combinedFileTemp, 'almond.js'));
    } catch (_error) {
      err = _error;
      return this.build.handleError(new UError("uRequire: error copying almond.js from uRequire's installation node_modules - is it installed ?\nTried: '" + __dirname + "/../../../node_modules/almond/almond.js'", {
        nested: err
      }));
    }
  };

  /*
   Copy all bundle's webMap dependencies to build.template._combinedFileTemp
   @todo: use path.join
   @todo: should copy dep.plugin & dep.resourceName separatelly
  */


  Bundle.prototype.copyWebMapDeps = function() {
    var depName, webRootDeps, _i, _len, _results;
    webRootDeps = _.keys(this.getDepsVars(function(dep) {
      return dep.depType === Dependency.TYPES.webRootMap;
    }));
    if (!_.isEmpty(webRootDeps)) {
      l.verbose("Copying webRoot deps :\n", webRootDeps);
      _results = [];
      for (_i = 0, _len = webRootDeps.length; _i < _len; _i++) {
        depName = webRootDeps[_i];
        _results.push(l.er("NOT IMPLEMENTED: copyWebMapDeps " + this.webRoot + depName + ", " + this.build.template._combinedFileTemp + depName));
      }
      return _results;
    }
  };

  logNestedErrorMessages = function(error) {
    var errorMessages;
    errorMessages = error.message || error + '';
    while (error.nested) {
      error = error.nested;
      errorMessages += '\n' + (error != null ? error.message : void 0);
    }
    return l.er(errorMessages);
  };

  Bundle.prototype.handleError = function(error) {
    if (error == null) {
      error = new UError("Undefined or null error!");
    }
    this.errorsCount++;
    if (error.quit) {
      throw error;
    } else {
      if (this.build) {
        logNestedErrorMessages(error);
        if (this.build["continue"] || this.build.watch) {
          l.er(error);
          l.warn("Continuing despite of error due to `build.continue` || `build.watch`");
        } else {
          error.quit = true;
          throw error;
        }
      } else {
        l.er(error.message);
        if (error.nested) {
          l.er("Nested error:\n", error.nested);
        }
        l.warn("Continuing despite of error, cause we have not one build (i.e we might have many!)");
      }
    }
    return null;
  };

  return Bundle;

})(BundleBase);

module.exports = Bundle;
